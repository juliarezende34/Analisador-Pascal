from LeitorArquivos import LeitorArquivos
from tokenizer import *
from output import *
from erros import *

with open('output.txt', 'w', encoding='utf-8') as f:
    # f.write(f"Código | Item{' ' *10} | Linha | Coluna\n")
    f.write(f"Código - Item - Linha - Coluna\n")
    f.close()

def tratamentoPalavra(cod, palavra, cont_linha, cont_coluna):

    # Se a palavra não está vazia, fazer tratamentos
    if palavra.strip() != '':

        # Printar itens reservados
        if (palavra in operadores_logicos) or (palavra in palavras_reservadas) or (palavra in io_tokens) or (palavra in condicionais):
            write_output(cod,palavra, cont_linha, cont_coluna)

        # Printar variável
        else:
            cod = 'variavel'
            write_output(cod, palavra, cont_linha, cont_coluna)
            cod = ''
            
        palavra = ''

    return palavra

Leitor = LeitorArquivos()

Leitor.LerArquivos()

arquivo = Leitor.get_lines_program('EXS1.pas')
palavra = ''
operador_aninhado = ''
delimitador = ''
cod = ''

aspas_dupla = False
aspas_simples = False
string_buffer = ''

cont_linha = 1
cont_coluna = 1

for linha in arquivo:
    cont_coluna = 1  # Resetar a coluna para cada nova linha
    for caracter in linha:

        # Tratamento de strings (aspas simples e duplas)
        if caracter == '"' and not aspas_simples:
            if aspas_dupla:
                # Fechamento de string com aspas duplas
                print(f"{string_buffer} - {cont_coluna}")
                write_output('string', string_buffer, cont_linha, cont_coluna - len(string_buffer))
                string_buffer = ''
                aspas_dupla = False
            else:
                # Abertura de string com aspas duplas
                aspas_dupla = True
            cont_coluna += 1
            continue
            
        elif caracter == "'" and not aspas_dupla:
            if aspas_simples:
                # Fechamento de string com aspas simples
                print(f"{string_buffer} - {cont_coluna}")
                write_output('string', string_buffer, cont_linha, cont_coluna - len(string_buffer))
                string_buffer = ''
                aspas_simples = False
            else:
                # Abertura de string com aspas simples
                aspas_simples = True
            cont_coluna += 1
            continue

        # Se estivermos dentro de uma string
        if aspas_dupla or aspas_simples:
            # Verifica se é uma barra invertida escapando uma aspas
            if caracter == '\\':  
                proximo_caracter = linha[cont_coluna] if cont_coluna < len(linha) else None
                if proximo_caracter in ['"', "'"]: 
                    # print("ue") 
                    string_buffer += proximo_caracter  
                    # cont_coluna += 1  # Pula o próximo caractere (já foi processado)
                else:
                    string_buffer += '\\'  
            else:
                string_buffer += caracter  # Caracter normal dentro da string
            cont_coluna += 1
            continue
        else:

            # Começo da construção dos caracteres aninhados - //, >=, <=, <>, :=, ==
            if (caracter in [':', '<', '>', '=', '/']) and (operador_aninhado == ''):
                #print(f"OLHA ISSO: {linha[cont_coluna]} e {palavra}")
                palavra = tratamentoPalavra(cod, palavra, cont_linha, cont_coluna)
                operador_aninhado = caracter
                cont_coluna += 1
                continue

            # Se houver os caracteres em sequência, constrói o caracter aninhado
            elif (operador_aninhado != '') and caracter in ['=', '>', '/']:
                operador_aninhado += caracter
                cont_coluna += 1
                continue

            # Se não for delimitador ou operador, continua a construir a palavra, letra por letra
            elif not (isDelimitador(caracter) or isOperadorAritmetico(caracter)):
                palavra = palavra + caracter

            # Achou um delimitador e a palavra foi construída
            else:
                # Se '//', é um comentário, então pula pra próxima linha
                if operador_aninhado == '//':
                    operador_aninhado = ''
                    palavra = ''
                    cont_coluna += 1
                    break

                # Se a palavra não está vazia, fazer tratamentos
                if palavra.strip() != '':
                    # Printar itens reservados
                    if (palavra in operadores_logicos) or (palavra in palavras_reservadas) or (palavra in io_tokens) or (palavra in condicionais):
                        print(f"{palavra} - {cont_coluna}")
                        write_output(cod,palavra, cont_linha, cont_coluna)

                    # Printar variável
                    else:
                        cod = 'variavel'
                        print(f"{palavra} - {cont_coluna}")
                        write_output(cod,palavra, cont_linha, cont_coluna)
                        cod = ''

                    if operador_aninhado != '':
                        print(f"{operador_aninhado} - {cont_coluna}")
                        write_output(cod,operador_aninhado, cont_linha, cont_coluna)
                        
                    if caracter in delimitadoresSalvar:
                        print(f"{caracter} - {cont_coluna}")
                        write_output('delimitador', caracter, cont_linha, cont_coluna)
                        
                    palavra = ''
                    operador_aninhado = ''
                elif caracter in delimitadoresSalvar:
                    #print(caracter)
                    print(f"{caracter} - {cont_coluna}")
                    write_output(cod, caracter, cont_linha, cont_coluna)
        #print(f"coluna: {cont_coluna}")
        cont_coluna += 1
        #teste = linha[cont_coluna] if cont_coluna < len(linha) else None
        #print(teste)
    cont_linha += 1

# Verifica se alguma string não foi fechada
if aspas_dupla or aspas_simples:
    print("Erro léxico: string não fechada")
    invalid_token_error()

print("Resultado da tokenização disponível no arquivo `output.txt`")